# -*- coding: utf-8 -*-
"""ANN Model to Predict Production Trends

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1n78snUwTqMSOmL7Z9sWe6wJs4Zph9qtn
"""

import pandas as pd
import numpy as np
import time
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.optimizers import Adam

# Load the dataset
file_path = "/content/278 Short String GL.xlsx"
df = pd.read_excel(file_path, sheet_name="Sheet1")

# Drop columns that are entirely NaN
df_cleaned = df.dropna(axis=1, how='all')

# Ensure "Datetime" column exists and is converted
if "Datetime" in df_cleaned.columns:
    df_cleaned["Datetime"] = pd.to_datetime(df_cleaned["Datetime"], errors='coerce')
    df_cleaned.dropna(subset=["Datetime"], inplace=True)
    df_cleaned.set_index("Datetime", inplace=True)

# Process each numeric column separately
results = {}
predictions_dict = {}

for column in df_cleaned.columns:
    if df_cleaned[column].dtype not in [np.float64, np.int64]:
        continue  # Skip non-numeric columns

    print(f"Processing: {column}")
    data = df_cleaned[[column]].dropna()

    # Normalize the data
    scaler = MinMaxScaler()
    scaled_data = scaler.fit_transform(data)

    # Function to create time series sequences
    def create_sequences(data, time_steps=5):
        X, y = [], []
        for i in range(len(data) - time_steps):
            X.append(data[i:i+time_steps].flatten())
            y.append(data[i+time_steps])
        return np.array(X), np.array(y)

    time_steps = 5
    X, y = create_sequences(scaled_data, time_steps)

    # Split into training and testing sets
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

    # Build ANN model
    model = Sequential([
        Dense(64, activation='relu', input_shape=(X_train.shape[1],)),
        Dense(64, activation='relu'),
        Dense(1)
    ])

    model.compile(optimizer=Adam(learning_rate=0.01), loss='mse')

    # Train the model and record training time
    start_time = time.time()
    model.fit(X_train, y_train, epochs=50, batch_size=8, validation_data=(X_test, y_test), verbose=0)
    end_time = time.time()
    training_time = end_time - start_time

    # Predict test set
    y_pred = model.predict(X_test)

    # Compute MAE and RMSE
    mae = mean_absolute_error(y_test, y_pred)
    rmse = np.sqrt(mean_squared_error(y_test, y_pred))

    results[column] = {"MAE": mae, "RMSE": rmse, "Training Time (s)": training_time}

    # Predict future values
    def predict_future(model, data, time_steps, future_days=60):
        predictions = []
        last_sequence = data[-time_steps:]
        for _ in range(future_days):
            pred = model.predict(last_sequence.reshape(1, -1))
            predictions.append(pred.flatten())
            last_sequence = np.vstack([last_sequence[1:], pred])
        return np.array(predictions)

    future_predictions = predict_future(model, scaled_data, time_steps, future_days=60)

    # Inverse transform predictions
    future_predictions = scaler.inverse_transform(future_predictions)

    # Store predictions
    future_dates = pd.date_range(start=data.index[-1], periods=61, freq='D')[1:]
    predicted_df = pd.DataFrame(future_predictions, columns=[column], index=future_dates)
    predictions_dict[column] = predicted_df

    print(f"MAE: {mae}, RMSE: {rmse}, Training Time: {training_time:.2f} seconds")

# Combine all predictions into one DataFrame
combined_predictions = pd.concat(predictions_dict.values(), axis=1)
combined_predictions.insert(0, "Datetime", combined_predictions.index)

# Save the combined predictions to a single CSV file
combined_predictions.to_csv("all_predictions.csv", index=False)
print("Saved all predictions to all_predictions.csv")

# Convert performance results into a DataFrame and save to CSV
performance_df = pd.DataFrame.from_dict(results, orient="index")
performance_df.index.name = "Parameter"
performance_df.to_csv("model_performance.csv")
print("Saved model performance metrics to model_performance.csv")